---
title: "密码学的学习笔记"
categories: [ "学习" ]
tags: [ "密码学" ]
draft: false
slug: "165"
date: 2024-03-01T10:49:25+08:00
---

密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密

信息安全（机密性，完整性，可用性，不可抵赖性）

---

Hash函数

hash可以用于校验文件是否完整，数字签名的摘要信息等等

hash函数是将任意大小的输入映射成固定大小的哈希值的函数

hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）

常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等

md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）

简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算

sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）

md5和sha1的计算过程：

先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的

也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间

确保这个消息的长度=输入消息+64+填充 = 512的整倍数

md5会初始化4个32bit的值，sha1会初始化5个32bit的值

md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算

每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值

计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值

如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果

mod 模计算

sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式

注意：md5和sha1都不安全了

md5

cryptographically broken and unsuitable for further use

users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use

sha1

谷歌SHA1碰撞实验

结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数

---

对称加密

AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14

计算过程：

AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）

128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵

加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵

先进行轮密钥加，每轮输入与轮密钥异或，得到的值，当解密的时候，只需要再异或该轮密钥即可得到输入，原理就是相同的两个数进行异或，结果为0，异或计算就是不带进位的二进制加法，1异或1，等于0，0异或1，等于1

然后字节替换（subbytes），经过轮密钥加每个字节通过十六进制进行表示，十六进制的第一个数为行，第二个数字为列，通过s盒找到对应十六进制进行替换，这个s盒是16x16的正方形矩阵，还有逆s盒，用来解密

s盒的16*16的十六进制是通过计算得到的，计算过程：

先进行16*16初始化，然后对每个元素计算其乘法逆元

以11为例（这个11是十六进制的），二进制为10001

10001的多项式为f(x) = x的5次方+1

意思为第1位和第五位为1

AES使用了不可约多项式m(x)=x8+x4+x3+x+1

行移位变换：就是将4*4的正方形矩阵的行都向左移动，例如第二行左移2位，第一行不变

列混淆变换：将4*4的正方形矩阵的取一列乘以C(X)矩阵，得到一个新的值，放回原来的位置

正方形矩阵的列和C(X)矩阵的行进行计算，就可以得到4*4的经过列混淆变换的新矩阵

列混淆变换计算过程：

假设取了A1，0B，BD，C1的一列数据

即（02*A1）,(03*0B)，(01*AF)，(01*C1)

通过十六进制转二进制，然后通过多项式表达式

02为10，为x

A1为10100001，为x的7次方+x的5次方+1

x乘以（x的7次方+x的5次方+1）= x的八次方+x的六次方+x

得到10100010，为A2

以此类推，得到四个二进制的值。然后这四个二进制进行异或相加，得到的值就是该列的新值

密钥扩展算法

将密钥编排成4个32位的初始密钥，最后一个32位的密钥通过G函数得到的结果，与第一个32位的密钥进行异或计算得到下一轮的第一个32位的密钥，下一轮的第一个32位的密钥和初始密钥的第二个的32位初始密钥进行异或，得到下一轮的第二个32位的密钥，一直计算到第11轮（轮密钥加需要进行10次，算上第0轮，也就是第11轮，也就是需要进行44次异或处理（4x11））

---

分组密码

非对称加密

数字签名和消息完整性

密钥的交换和数字信任链

编码和解码
